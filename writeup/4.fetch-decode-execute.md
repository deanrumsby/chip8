# Fetch, Decode & Execute

So now we have some instructions in our memory, we need to start reading them (fetch), figuring out what to do with them (decode) and then actually do that (execute)!

Let's add the skeleton of that into our code. 

```javascript
fetch() {
        const u16 = this.view.getUint16(this.pc);
        this.pc += 2;
        return u16;
    }
```

However at this point I am going to use some foresight to make a decision. We would like to now compare the bytes in this fetched instructions to determine what we should execute. Normally I would make a switch statement to achieve this, but I'm going to extract the logic into a separate `Instruction` class. I'm doing this because I know that I would like to build a disassembler next, so that we can view the instructions we are processing. This disassembling process will need to decode the instructions in an identical manner, so I will extract that logic out now to save the hassle refactoring.

Here is my new class

*instruction.js*
```javascript
class Instruction {
    constructor(value) {
        this.value = value;
        this.type = this.decode(value);
    }

    decode(value) {
        const opcode = (value & 0xf000) >> 12;

        switch (opcode) {
            case 0x0: {
                return "00E0";
            }
            case 0x1: {
                return "1NNN";
            }
            case 0x6: {
                return "6XNN";
            }
            case 0x7: {
                return "7XNN";
            }
            case 0xa: {
                return "ANNN";
            }
            case 0xd: {
                return "DXYN";
            }
        };
    }

    opcode() {
        return (this.value & 0xf000) >> 12;
    }

    x() {
        return (this.value & 0x0f00) >> 8;
    }

    y() {
        return (this.value & 0x00f0) >> 4;
    }

    nnn() {
        return this.value & 0x0fff;
    }

    nn() {
        return this.value & 0x00ff;
    }

    n() {
        return this.value & 0x000f;
    }
}

export default Instruction;
```

so that my fetch function now becomes:

*chip8.js*
```javascript
fetch() {
        const u16 = this.view.getUint16(this.pc);
        this.pc += 2;
        return new Instruction(u16);
}
```

Now in our execute block we can switch on the instruction type and not have to worry about decoding. I keep the logic for parsing `X`, `Y`, `NNN` etc within functions, essentially so they are lazily evaluated and only calculated when needed (since most are not needed by each instruction type).





